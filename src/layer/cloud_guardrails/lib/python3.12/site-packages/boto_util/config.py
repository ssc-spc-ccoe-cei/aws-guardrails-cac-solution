import json
import time

import botocore.exceptions
from utils import GuardrailRequirementType


def build_evaluation(
    resource_id: str,
    compliance_type: str,
    event: dict,
    resource_type: str = "AWS::::Account",
    annotation: str | None = None,
    gr_requirement_type: GuardrailRequirementType = GuardrailRequirementType.Required,
) -> dict:
    """
    Form an evaluation as a dictionary. Usually suited to report on scheduled rules.

    Keyword arguments:

        resource_id -- the unique id of the resource to report

        compliance_type -- either COMPLIANT, NON_COMPLIANT or NOT_APPLICABLE

        event -- the event variable given in the lambda handler

        resource_type -- the CloudFormation resource type to report on the rule (default AWS::::Account)

        annotation -- an annotation to be added to the evaluation (default None)
    """

    evaluation = {
        "ComplianceResourceId": resource_id,
        "ComplianceResourceType": resource_type,
        "OrderingTimestamp": str(json.loads(event["invokingEvent"])["notificationCreationTime"]),
    }

    match gr_requirement_type:
        case GuardrailRequirementType.Required:
            evaluation["ComplianceType"] = compliance_type
            if annotation:
                # Truncates any annotation longer than 256 to avoid an error with submission
                evaluation["Annotation"] = annotation[:256]
        case GuardrailRequirementType.Recommended:
            evaluation["ComplianceType"] = "COMPLIANT"
            evaluation["Annotation"] = "This guardrail is not required for the accounts cloud profile level."
        case GuardrailRequirementType.Not_Required:
            evaluation["ComplianceType"] = "NOT_APPLICABLE"

    return evaluation


def submit_evaluations(config_client, event: dict, evaluations: list[dict], interval_between_calls: float = 0.05):
    """
    Submit the list of evaluations to AWS Config Service in batches.
    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/config/client/put_evaluations.html

    Keyword arguments:

    config_client -- The aws client for the 'config' service

    event -- The event object given to the lambda handler

    evaluations -- A list of evaluations

    interval_between_calls -- A time to wait between batches of submissions, used to prevent API throttling
    """

    # The maximum amount of evaluations that the API allows to be submitted in one request is 100
    evaluations_per_request = 100

    # Append evaluations for missing resources
    modified_evaluations = append_not_applicable_results_for_removed_resources(config_client, event, evaluations)

    try:
        while modified_evaluations:
            batch_of_evaluations, modified_evaluations = (
                modified_evaluations[:evaluations_per_request],
                modified_evaluations[evaluations_per_request:],
            )
            config_client.put_evaluations(Evaluations=batch_of_evaluations, ResultToken=event["resultToken"])
            if modified_evaluations:
                time.sleep(interval_between_calls)

    except botocore.exceptions.ClientError as ex:
        # Scrub error message for any internal account info leaks
        if "AccessDenied" in ex.response["Error"]["Code"]:
            ex.response["Error"]["Message"] = "AWS Config does not have permission to assume the IAM role."
        elif "InvalidParameterValue" in ex.response["Error"]["Code"]:
            ex.response["Error"]["Message"] = "InvalidParameterValue when calling put_evaluations"
        elif "InvalidResultToken" in ex.response["Error"]["Code"]:
            ex.response["Error"]["Message"] = "InvalidResultToken when calling put_evaluations"
        elif "NoSuchConfigRule" in ex.response["Error"]["Code"]:
            ex.response["Error"]["Message"] = "NoSuchConfigRule when calling put_evaluations"
        else:
            ex.response["Error"]["Message"] = "InternalError"
            ex.response["Error"]["Code"] = "InternalError"
        raise ex


def append_not_applicable_results_for_removed_resources(config_client, event: dict, evaluations: list[dict]):
    # Get the list of NON_COMPLIANT evaluations present in aws config
    try:
        compliance_details = get_all_compliance_details_by_config_rule(
            config_client, event["configRuleName"], ["NON_COMPLIANT"]
        )
    except botocore.exceptions.ClientError as ex:
        if "NoSuchConfigRule" in ex.response["Error"]["Code"]:
            compliance_details = []
        else:
            raise ex

    if not compliance_details:
        # No results means there are no NON_COMPLIANT evaluations to overwrite
        return evaluations

    new_evaluations_tuples = set([(x["ComplianceResourceId"], x["ComplianceResourceType"]) for x in evaluations])

    not_applicable_evaluations = [
        # Create a new evaluation to overwrite the results in aws config since this resource is not found in the new evaluations list
        build_evaluation(
            x["EvaluationResultIdentifier"]["EvaluationResultQualifier"]["ResourceId"],
            "NOT_APPLICABLE",
            event,
            x["EvaluationResultIdentifier"]["EvaluationResultQualifier"]["ResourceType"],
            "Resource not included with the latest evaluation results.",
        )
        for x in compliance_details
        # Filter out results that are included in the new evaluations list already
        if (
            x["EvaluationResultIdentifier"]["EvaluationResultQualifier"]["ResourceId"],
            x["EvaluationResultIdentifier"]["EvaluationResultQualifier"]["ResourceType"],
        )
        not in new_evaluations_tuples
    ]
    return evaluations + not_applicable_evaluations


def describe_all_config_rules(config_client, interval_between_calls: float = 0.05) -> list[dict]:
    """
    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/config/paginator/DescribeConfigRules.html
    """
    resources: list[dict] = []
    paginator = config_client.get_paginator("describe_config_rules")
    page_iterator = paginator.paginate()
    for page in page_iterator:
        resources.extend(page.get("ConfigRules", []))
        time.sleep(interval_between_calls)
    return resources


def aws_config_is_enabled(config_client):
    result = config_client.describe_configuration_recorder_status()
    recorders_status = result.get("ConfigurationRecordersStatus")
    for status in recorders_status:
        if status.get("recording", False) == True:
            return True
    return False


def get_all_compliance_details_by_config_rule(
    config_client, config_rule_name: str, compliance_types: list[str] = None, interval_between_calls: float = 0.05
) -> list[dict]:
    """
    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/config/paginator/GetComplianceDetailsByConfigRule.html
    """
    args = {"ConfigRuleName": config_rule_name}
    if compliance_types:
        args["ComplianceTypes"] = compliance_types

    resources: list[dict] = []
    paginator = config_client.get_paginator("get_compliance_details_by_config_rule")
    page_iterator = paginator.paginate(**args)
    for page in page_iterator:
        resources.extend(page.get("EvaluationResults", []))
        time.sleep(interval_between_calls)
    return resources
